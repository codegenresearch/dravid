import traceback from ...api.main import call_dravid_api from ...utils.step_executor import Executor from ...utils.utils import print_error, print_success, print_info, print_command_details from ...utils.loader import run_with_loader from ...prompts.monitor_error_resolution import get_error_resolution_prompt from ..query.file_operations import get_files_to_modify from ...utils.file_utils import get_file_content\ndef monitoring_handle_error_with_dravid(error, line, monitor): print_error(f"Error detected: {error}")\nerror_message = str(error) error_type = type(error).__name__ error_trace = ''.join(traceback.format_exception(type(error), error, error.__traceback__))\nproject_context = monitor.metadata_manager.get_project_context()\nprint_info("Identifying relevant files for error context...") error_details = f"error_msg: {error_message}, error_type: {error_type}, error_trace: {error_trace}" files_to_check = run_with_loader( lambda: get_files_to_modify(error_details, project_context), "Analyzing project files" )\nfile_contents = {file: content for file in files_to_check if (content := get_file_content(file))}\nfile_context = "\n".join(f"Content of {file}:\n{content}" for file, content in file_contents.items())\nerror_query = get_error_resolution_prompt( error_type, error_message, error_trace, line, project_context, file_context )\nprint_info("Sending error information to Dravid for analysis...") try: commands = call_dravid_api(error_query, include_context=True) except ValueError as e: print_error(f"Error parsing Dravid's response: {str(e)}") return False\nrequires_restart = any(cmd['type'] == 'requires_restart' and cmd['content'].lower() == 'true' for cmd in commands) fix_commands = [cmd for cmd in commands if cmd['type'] != 'requires_restart' and cmd['type'] != 'explanation']\nprint_info("Dravid's suggested fix:") print_command_details(fix_commands)\nif monitor.get_user_input("Do you want to proceed with this fix? You will be able to stop anytime during the step. [y/N]: ").lower() == 'y': print_info("Applying Dravid's suggested fix...") executor = Executor() for cmd in fix_commands: if cmd['type'] == 'shell': executor.execute_shell_command(cmd['command']) elif cmd['type'] == 'file': executor.perform_file_operation(cmd['operation'], cmd['filename'], cmd.get('content'))\nprint_success("Fix applied.")\nif requires_restart: if monitor.get_user_input("Do you want to restart the server now? [y/N]: ").lower() == 'y': monitor.request_restart() else: print_info("Server restart postponed. You may need to restart manually if issues persist.") return True else: print_info("The applied fix does not require a server restart.") return True else: print_info("Fix not applied. Continuing with current state.") return False