import unittest\nfrom unittest.mock import patch, mock_open, MagicMock\nimport os\nimport json\nimport subprocess\nfrom io import StringIO\n\nfrom drd.utils.step_executor import Executor\nfrom drd.utils.apply_file_changes import apply_changes\n\nclass TestExecutor(unittest.TestCase):\n\n    def setUp(self):\n        self.executor = Executor()\n\n    def test_is_safe_path(self):\n        self.assertTrue(self.executor.is_safe_path(os.path.join(self.executor.current_dir, 'test.txt')))\n        self.assertFalse(self.executor.is_safe_path('/etc/passwd'))\n\n    def test_is_safe_rm_command(self):\n        self.assertFalse(self.executor.is_safe_rm_command('rm test.txt'))\n        with patch('os.path.isfile', return_value=True):\n            self.assertTrue(self.executor.is_safe_rm_command(\n                'rm existing_file.txt'))\n        self.assertFalse(self.executor.is_safe_rm_command('rm -rf /'))\n        self.assertFalse(self.executor.is_safe_rm_command('rm -f test.txt'))\n\n    def test_is_safe_command(self):\n        self.assertTrue(self.executor.is_safe_command('ls'))\n        self.assertFalse(self.executor.is_safe_command('sudo rm -rf /'))\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    def test_perform_file_operation_create(self, mock_file, mock_exists):\n        mock_exists.return_value = False\n        result = self.executor.perform_file_operation(\n            'CREATE', 'test.txt', 'content')\n        self.assertTrue(result)\n        mock_file.assert_called_with(os.path.join(\n            self.executor.current_dir, 'test.txt'), 'w')\n        mock_file().write.assert_called_with('content')\n\n    @patch('os.path.exists')\n    @patch('os.path.isfile')\n    @patch('os.remove')\n    def test_perform_file_operation_delete(self, mock_remove, mock_isfile, mock_exists):\n        mock_exists.return_value = True\n        mock_isfile.return_value = True\n        result = self.executor.perform_file_operation('DELETE', 'test.txt')\n        self.assertTrue(result)\n        mock_remove.assert_called_with(os.path.join(\n            self.executor.current_dir, 'test.txt'))\n\n    def test_parse_json(self):\n        valid_json = '{"key": "value"}'\n        invalid_json = '{key: value}'\n        self.assertEqual(self.executor.parse_json(\n            valid_json), {"key": "value"})\n        self.assertIsNone(self.executor.parse_json(invalid_json))\n\n    def test_merge_json(self):\n        existing_content = '{"key1": "value1"}'\n        new_content = '{"key2": "value2"}'\n        expected_result = json.dumps(\n            {"key1": "value1", "key2": "value2"}, indent=2)\n        self.assertEqual(self.executor.merge_json(\n            existing_content, new_content), expected_result)\n\n    @patch('drd.utils.step_executor.get_ignore_patterns')\n    @patch('drd.utils.step_executor.get_folder_structure')\n    def test_get_folder_structure(self, mock_get_folder_structure, mock_get_ignore_patterns):\n        mock_get_ignore_patterns.return_value = ([], None)\n        mock_get_folder_structure.return_value = {\n            'folder': {'file.txt': 'file'}}\n        result = self.executor.get_folder_structure()\n        self.assertEqual(result, {\n            'folder': {'file.txt': 'file'}})\n\n    @patch('subprocess.Popen')\n    def test_execute_shell_command(self, mock_popen):\n        mock_process = MagicMock()\n        mock_process.poll.side_effect = [None, 0]\n        mock_process.stdout.readline.return_value = 'output line'\n        mock_process.communicate.return_value = ('', '')\n        mock_popen.return_value = mock_process\n\n        result = self.executor.execute_shell_command('ls')\n        self.assertEqual(result, 'output line')\n\n    @patch('subprocess.run')\n    def test_handle_source_command(self, mock_run):\n        mock_run.return_value = subprocess.CompletedProcess(\n            args=['source', 'test.sh'],\n            returncode=0,\n            stdout='KEY=value\n',\n            stderr=''\n        )\n        with patch('os.path.isfile', return_value=True):\n            result = self.executor._handle_source_command('source test.sh')\n        self.assertEqual(result, "Source command executed successfully")\n        self.assertEqual(self.executor.env['KEY'], 'value')\n\n    def test_update_env_from_command(self):\n        self.executor._update_env_from_command('TEST_VAR=test_value')\n        self.assertEqual(self.executor.env['TEST_VAR'], 'test_value')\n\n        self.executor._update_env_from_command(\n            'export EXPORT_VAR=export_value')\n        self.assertEqual(self.executor.env['EXPORT_VAR'], 'export_value')\n\n        self.executor._update_env_from_command('set SET_VAR=set_value')\n        self.assertEqual(self.executor.env['SET_VAR'], 'set_value')\n\n        self.executor._update_env_from_command('QUOTE_VAR="quoted value"')\n        self.assertEqual(self.executor.env['QUOTE_VAR'], 'quoted value')\n\n        self.executor._update_env_from_command(\n            'export EXPORT_QUOTE="exported quoted value"')\n        self.assertEqual(\n            self.executor.env['EXPORT_QUOTE'], 'exported quoted value')\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open)\n    @patch('click.confirm')\n    def test_perform_file_operation_create_with_confirmation(self, mock_confirm, mock_file, mock_exists):\n        mock_exists.return_value = False\n        mock_confirm.return_value = True\n        result = self.executor.perform_file_operation(\n            'CREATE', 'test.txt', 'content')\n        self.assertTrue(result)\n        mock_file.assert_called_with(os.path.join(\n            self.executor.current_dir, 'test.txt'), 'w')\n        mock_file().write.assert_called_with('content')\n        mock_confirm.assert_called_once()\n\n    @patch('os.path.exists')\n    @patch('builtins.open', new_callable=mock_open, read_data="original content")\n    @patch('click.confirm')\n    @patch('drd.utils.step_executor.preview_file_changes')\n    def test_perform_file_operation_update_with_confirmation(self, mock_preview, mock_confirm, mock_file, mock_exists):\n        mock_exists.return_value = True\n        mock_confirm.return_value = True\n        mock_preview.return_value = "Preview of changes"\n        changes = "+ 2: This is a new line\nr 1: This is a replaced line"\n        result = self.executor.perform_file_operation(\n            'UPDATE', 'test.txt', changes)\n        self.assertTrue(result)\n        mock_file.assert_any_call(os.path.join(\n            self.executor.current_dir, 'test.txt'), 'r')\n        mock_file.assert_any_call(os.path.join(\n            self.executor.current_dir, 'test.txt'), 'w')\n        expected_updated_content = apply_changes("original content", changes)\n        mock_preview.assert_called_once_with(\n            'UPDATE', 'test.txt', new_content=expected_updated_content, original_content="original content")\n        mock_file().write.assert_called_once_with(expected_updated_content)\n\n    @patch('os.path.exists')\n    @patch('os.path.isfile')\n    @patch('os.remove')\n    @patch('click.confirm')\n    def test_perform_file_operation_delete_with_confirmation(self, mock_confirm, mock_remove, mock_isfile, mock_exists):\n        mock_exists.return_value = True\n        mock_isfile.return_value = True\n        mock_confirm.return_value = True\n        result = self.executor.perform_file_operation('DELETE', 'test.txt')\n        self.assertTrue(result)\n        mock_remove.assert_called_with(os.path.join(\n            self.executor.current_dir, 'test.txt'))\n        mock_confirm.assert_called_once()\n\n    @patch('click.confirm')\n    def test_perform_file_operation_user_cancel(self, mock_confirm):\n        mock_confirm.return_value = False\n        result = self.executor.perform_file_operation(\n            'UPDATE', 'test.txt', 'content')\n        self.assertFalse(result)\n\n    @patch('subprocess.Popen')\n    @patch('click.confirm')\n    def test_execute_shell_command_with_confirmation(self, mock_confirm, mock_popen):\n        mock_confirm.return_value = True\n        mock_process = MagicMock()\n        mock_process.poll.side_effect = [None, 0]\n        mock_process.stdout.readline.return_value = 'output line'\n        mock_process.communicate.return_value = ('', '')\n        mock_popen.return_value = mock_process\n\n        result = self.executor.execute_shell_command('ls')\n        self.assertEqual(result, 'output line')\n        mock_confirm.assert_called_once()\n\n    @patch('click.confirm')\n    def test_execute_shell_command_user_cancel(self, mock_confirm):\n        mock_confirm.return_value = False\n        result = self.executor.execute_shell_command('ls')\n        mock_confirm.assert_called_once()\n